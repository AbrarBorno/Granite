#version 450
layout(local_size_x = 8, local_size_y = 8) in;

layout(set = 0, binding = 0, rgba8) uniform writeonly mediump image2D uOutput;
layout(set = 0, binding = 1) uniform mediump sampler2D uY;
layout(set = 0, binding = 2) uniform mediump sampler2D uCb;
layout(set = 0, binding = 3) uniform mediump sampler2D uCr;

layout(push_constant) uniform Registers
{
    uvec2 resolution;
    vec2 inv_resolution;
    vec2 chroma_siting;
} registers;

layout(set = 1, binding = 0) uniform UBO
{
    mediump mat4 yuv_to_rgb;
    mediump mat4 primary_conversion;
};

const int EOTF_BT2087 = 0;
layout(constant_id = 0) const int EOTF = 0;

mediump vec3 srgb_oetf(mediump vec3 col)
{
    return mix(col * 12.92, 1.055 * pow(col, vec3(1.0 / 2.4) - 0.055), greaterThan(col, vec3(0.0031308)));
}

#define D(x) (((x) - 0.5) / 255.0)
const mediump float dither[] = float[](
    D(0.0625), D(0.5625), D(0.1875), D(0.6875),
    D(0.8125), D(0.3125), D(0.9375), D(0.4375),
    D(0.25), D(0.75), D(0.125), D(0.625),
    D(1.00), D(0.5), D(0.875), D(0.375));

void main()
{
    uvec2 coord = gl_GlobalInvocationID.xy;
    if (all(lessThan(coord, registers.resolution)))
    {
        vec2 fcoord = vec2(coord);
        vec2 chroma_coord = (fcoord + registers.chroma_siting) * registers.inv_resolution;
        vec2 luma_coord = (fcoord + 0.5) * registers.inv_resolution;

        // Reconstruct full resolution Y'CbCr.
        mediump float y = textureLod(uY, luma_coord, 0.0).x;
        mediump float cb = textureLod(uCb, chroma_coord, 0.0).x;
        mediump float cr = textureLod(uCr, chroma_coord, 0.0).x;

        // Convert to R'G'B'.
        mediump vec3 rgb = (yuv_to_rgb * vec4(y, cb, cr, 1.0)).rgb;

        // Apply EOTF.
        rgb = clamp(rgb, vec3(0.0), vec3(1.0));
        if (EOTF == EOTF_BT2087)
            rgb = pow(rgb, vec3(2.4));

        // Convert primaries to BT.709 (sRGB).
        rgb = (primary_conversion * vec4(rgb, 0.0)).rgb;
        rgb = clamp(rgb, vec3(0.0), vec3(1.0));

        // Encode to sRGB OETF.
        rgb = srgb_oetf(rgb);

        // Dither the output to avoid banding in the OETF(EOTF(x)) conversion.
        rgb += dither[4u * (gl_LocalInvocationID.y & 3u) + (gl_LocalInvocationID.x & 3u)];

        imageStore(uOutput, ivec2(coord), vec4(rgb, 1.0));
    }
}