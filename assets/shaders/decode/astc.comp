#version 450
#extension GL_EXT_samplerless_texture_functions : require
layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 4) in;

#include "bitextract.h"
#include "../inc/debug_channel.h"

uvec3 debug_coord;
#define DEBUG1(x) add_debug_message(0, debug_coord, uvec2(__LINE__, x))
#define DEBUG2(x, y) add_debug_message(0, debug_coord, uvec3(__LINE__, x, y))
#define DEBUG3(x, y, z) add_debug_message(0, debug_coord, uvec4(__LINE__, x, y, z))

layout(set = 1, binding = 0) uniform utextureBuffer LUTRemainingBitsToEndpointQuantizer;
layout(set = 1, binding = 1) uniform utextureBuffer LUTEndpointUnquantize;
layout(set = 1, binding = 2) uniform utextureBuffer LUTWeightQuantizer;
layout(set = 1, binding = 3) uniform utextureBuffer LUTWeightUnquantize;
layout(set = 1, binding = 4) uniform utextureBuffer LUTTritQuintDecode;

layout(set = 0, binding = 0, rgba8ui) writeonly uniform uimage2D OutputImageU8;
layout(set = 0, binding = 0, rgba16ui) writeonly uniform uimage2D OutputImageFP16;
layout(set = 0, binding = 1) uniform utexture2D PayloadInput;
layout(constant_id = 2) const bool DECODE_8BIT = false;

layout(push_constant) uniform Registers
{
    ivec2 resolution;
} registers;

ivec4 build_coord()
{
    ivec2 payload_coord = ivec2(gl_WorkGroupID.xy) * 2;
    payload_coord.x += int(gl_LocalInvocationID.z) & 1;
    payload_coord.y += (int(gl_LocalInvocationID.z) >> 1) & 1;
    ivec2 coord = payload_coord * ivec2(gl_WorkGroupSize.xy);
    coord += ivec2(gl_LocalInvocationID.xy);
    return ivec4(coord, payload_coord);
}

ivec4 interpolate_endpoint(ivec4 ep0, ivec4 ep1, ivec4 weight, bool HDR_endpoint)
{
    if (HDR_endpoint)
    {
        ep0 <<= 4;
        ep1 <<= 4;
    }
    else if (DECODE_8BIT)
    {
        // This isn't quite right in all cases.
        // In normal ASTC with sRGB, the alpha channel is supposed to
        // be decoded as FP16,
        // even when color components are SRGB 8-bit (?!?!?!?!).
        // This is correct if decode_unorm8 mode is used though,
        // for sanity, we're going to assume unorm8 decoding mode
        // is implied when using sRGB.
        ep0 = (ep0 << 8) | ivec4(0x80);
        ep1 = (ep1 << 8) | ivec4(0x80);
    }
    else
    {
        ep0 *= 0x101;
        ep1 *= 0x101;
    }

    ivec4 color = (ep0 * (64 - weight) + ep1 * weight + 32) >> 6;
    return color;
}

uvec4 decode_fp16(ivec4 color)
{
    // ASTC has a very peculiar way of converting the decoded result to FP16.
    // 0xffff -> 1.0, and for everything else we get roundDownQuantizeFP16(vec4(c) / vec4(0x10000)).

    ivec4 msb = findMSB(color);
    ivec4 shamt = msb;
    ivec4 m = ((color << 10) >> shamt) & 0x3ff;
    ivec4 e = msb - 1;
    uvec4 decoded = m | (e << 10);
    uvec4 denorm_decode = color << 8;
    decoded = mix(decoded, uvec4(denorm_decode), lessThan(e, ivec4(1)));
    decoded = mix(decoded, uvec4(0x3c00), equal(color, ivec4(0xffff)));
    return decoded;
}

struct BlockMode
{
    ivec2 weight_grid_size;
    int weight_mode_index;
    int num_partitions;
    int seed;
    int cem;
    int config_bits;
    bool dual_plane;
    bool void_extent;
};

bool decode_error = false;

BlockMode decode_block_mode(uvec4 payload)
{
    BlockMode mode;
    mode.void_extent = (payload.x & 0x1ffu) == 0x1fcu;
    mode.dual_plane = (payload.x & (1u << 10u)) != 0u;

    uint higher = (payload.x >> 2u) & 3u;
    uint lower = payload.x & 3u;

    if (lower != 0)
    {
        mode.weight_mode_index = int((payload.x >> 4u) & 1u);
        mode.weight_mode_index |= int((payload.x << 1u) & 6u);
        mode.weight_mode_index |= int((payload.x >> 6u) & 8u);

        if (higher < 2u)
        {
            mode.weight_grid_size.x = int(bitfieldExtract(payload.x, 7, 2) + 4 + 4 * higher);
            mode.weight_grid_size.y = int(bitfieldExtract(payload.x, 5, 2) + 2);
        }
        else if (higher == 2u)
        {
            mode.weight_grid_size.x = int(bitfieldExtract(payload.x, 5, 2) + 2);
            mode.weight_grid_size.y = int(bitfieldExtract(payload.x, 7, 2) + 8);
        }
        else
        {
            if ((payload.x & (1u << 8u)) != 0u)
            {
                mode.weight_grid_size.x = int(bitfieldExtract(payload.x, 7, 1) + 2);
                mode.weight_grid_size.y = int(bitfieldExtract(payload.x, 5, 2) + 2);
            }
            else
            {
                mode.weight_grid_size.x = int(bitfieldExtract(payload.x, 5, 2) + 2);
                mode.weight_grid_size.y = int(bitfieldExtract(payload.x, 7, 1) + 6);
            }
        }
    }
    else
    {
        int p3 = int(bitfieldExtract(payload.x, 9, 1));
        int hi = int(bitfieldExtract(payload.x, 7, 2));
        int lo = int(bitfieldExtract(payload.x, 5, 2));
        if (hi == 0)
        {
            mode.weight_grid_size.x = 12;
            mode.weight_grid_size.y = lo + 2;
        }
        else if (hi == 1)
        {
            mode.weight_grid_size.x = lo + 2;
            mode.weight_grid_size.y = 12;
        }
        else if (hi == 2)
        {
            mode.dual_plane = false;
            p3 = 0;
            mode.weight_grid_size.x = lo + 6;
            mode.weight_grid_size.y = int(bitfieldExtract(payload.x, 9, 2) + 6);
        }
        else
        {
            if (lo == 0)
                mode.weight_grid_size = ivec2(6, 10);
            else if (lo == 1)
                mode.weight_grid_size = ivec2(10, 6);
            else
                decode_error = true;
        }

        int p0 = int(bitfieldExtract(payload.x, 4, 1));
        int p1 = int(bitfieldExtract(payload.x, 2, 1));
        int p2 = int(bitfieldExtract(payload.x, 3, 1));
        mode.weight_mode_index = p0 + (p1 << 1) + (p2 << 2) + (p3 << 3);
    }

    mode.num_partitions = int(bitfieldExtract(payload.x, 11, 2)) + 1;

    if (mode.num_partitions > 1)
    {
        mode.cem = int(bitfieldExtract(payload.x, 23, 6));
        mode.seed = int(bitfieldExtract(payload.x, 13, 10));
    }
    else
        mode.cem = int(bitfieldExtract(payload.x, 13, 4));

    int config_bits = 17;
    if (mode.num_partitions > 1)
    {
        bool single_cem = (mode.cem & 3) == 0;
        if (single_cem)
            config_bits = 29;
        else
            config_bits = 25 + 3 * mode.num_partitions;
    }

    if (mode.dual_plane)
        config_bits += 2;

    // This is not allowed.
    if (any(greaterThan(mode.weight_grid_size, ivec2(gl_WorkGroupSize.xy))))
        decode_error = true;
    if (mode.dual_plane && mode.num_partitions > 3)
        decode_error = true;

    mode.config_bits = config_bits;
    return mode;
}

int idiv3_floor(int v)
{
    return (v * 0x5556) >> 16;
}

int idiv3_ceil(int v)
{
    return idiv3_floor(v + 2);
}

int idiv5_floor(int v)
{
    return (v * 0x3334) >> 16;
}

int idiv5_ceil(int v)
{
    return idiv5_floor(v + 4);
}

uvec4 build_bitmask(int bits)
{
    ivec4 num_bits = ivec4(bits, bits - 32, bits - 64, bits - 96);
    uvec4 mask = uvec4(1) << clamp(num_bits, ivec4(0), ivec4(31));
    mask--;
    mask = mix(mask, uvec4(0xffffffffu), greaterThanEqual(uvec4(bits), uvec4(32, 64, 96, 128)));
    return mask;
}

int decode_integer_sequence(uvec4 payload, int start_bit, int index, int max_bits, ivec3 quant)
{
    payload &= build_bitmask(max_bits);

    int ret;
    if (quant.y != 0)
    {
        // Trit-decoding.
        int block = idiv5_floor(index);
        int offset = index - block * 5;
        start_bit += block * (5 * quant.x + 8);

        int t0_t1_offset = start_bit + (quant.x * 1 + 0);
        int t2_t3_offset = start_bit + (quant.x * 2 + 2);
        int t4_offset    = start_bit + (quant.x * 3 + 4);
        int t5_t6_offset = start_bit + (quant.x * 4 + 5);
        int t7_offset    = start_bit + (quant.x * 5 + 7);

        int t = (extract_bits(payload, t0_t1_offset, 2) << 0) |
                (extract_bits(payload, t2_t3_offset, 2) << 2) |
                (extract_bits(payload, t4_offset, 1) << 4) |
                (extract_bits(payload, t5_t6_offset, 2) << 5) |
                (extract_bits(payload, t7_offset, 1) << 7);

        t = int(texelFetch(LUTTritQuintDecode, t).x);
        t = (t >> (3 * offset)) & 7;

        int m_offset = offset * quant.x;
        m_offset += idiv5_ceil(offset * 8);

        if (quant.x != 0)
        {
            int m = extract_bits(payload, m_offset + start_bit, quant.x);
            ret = (t << quant.x) | m;
        }
        else
            ret = t;
    }
    else if (quant.z != 0)
    {
        // Quint-decoding
        int block = idiv3_floor(index);
        int offset = index - block * 3;
        start_bit += block * (3 * quant.x + 7);

        int q0_q1_q2_offset = start_bit + (quant.x * 1 + 0);
        int q3_q4_offset    = start_bit + (quant.x * 2 + 3);
        int q5_q6_offset    = start_bit + (quant.x * 4 + 5);

        int q = (extract_bits(payload, q0_q1_q2_offset, 3) << 0) |
                (extract_bits(payload, q3_q4_offset, 2) << 3) |
                (extract_bits(payload, q5_q6_offset, 2) << 5);

        q = int(texelFetch(LUTTritQuintDecode, 256 + q).x);
        q = (q >> (3 * offset)) & 7;

        int m_offset = offset * quant.x;
        m_offset += idiv3_ceil(offset * 7);

        if (quant.x != 0)
        {
            int m = extract_bits(payload, m_offset + start_bit, quant.x);
            ret = (q << quant.x) | m;
        }
        else
            ret = q;
    }
    else
    {
        int bit = index * quant.x;
        ret = extract_bits(payload, start_bit + bit, quant.x);
    }
    return ret;
}

ivec4 decode_weights(uvec4 payload, BlockMode mode, int pixel, out int weight_cost_bits)
{
    payload = bitfieldReverse(payload);
    payload = payload.wzyx;

    ivec4 quant = ivec4(texelFetch(LUTWeightQuantizer, mode.weight_mode_index));
    DEBUG3(quant.x, quant.y, quant.z);
    int num_weights = mode.weight_grid_size.x * mode.weight_grid_size.y;
    num_weights *= int(mode.dual_plane) + 1;
    weight_cost_bits =
        quant.x * num_weights +
        idiv5_ceil(num_weights * 8 * quant.y) +
        idiv3_ceil(num_weights * 7 * quant.z);

    DEBUG1(weight_cost_bits);

    // Decoders must deal with error conditions and return the correct error color.
    if (weight_cost_bits < 24 || weight_cost_bits > 96 || num_weights > 64)
        decode_error = true;

    int weight_index = pixel;
    int primary_weight = decode_integer_sequence(payload, 0, weight_index, weight_cost_bits, quant.xyz);
    DEBUG1(primary_weight);
    DEBUG1(quant.w);
    primary_weight = int(texelFetch(LUTWeightUnquantize, primary_weight + quant.w).x);
    DEBUG1(primary_weight);
    return ivec4(primary_weight);
}

void decode_endpoint(out ivec4 ep0, out ivec4 ep1, out bool HDR,
                     uvec4 payload, int bit_offset, ivec4 quant, int ep_mode, int num_endpoint_bits)
{
    num_endpoint_bits += bit_offset;

    int vals[8];
    int num_values = 2 * ((ep_mode >> 2) + 1);

    for (int i = 0; i < num_values; i++)
    {
        int v = decode_integer_sequence(payload, bit_offset, i, num_endpoint_bits, quant.xyz);
        v = int(texelFetch(LUTEndpointUnquantize, quant.w + v).x);
        vals[i] = v;
    }

    switch (ep_mode >> 2)
    {
    case 0:
    {
        int v0 = vals[0];
        int v1 = vals[1];
        switch (ep_mode & 3)
        {
        case 0: // LDR Luminance
            ep0 = ivec4(v0, v0, v0, 0xff);
            ep1 = ivec4(v1, v1, v1, 0xff);
            HDR = false;
            break;

        default:
            decode_error = true;
            break;
        }
        break;
    }

    default:
        decode_error = true;
        break;
    }
}

#define CHECK_DECODE_ERROR() do { \
    if (decode_error) \
    { \
        emit_decode_error(coord.xy); \
        return; \
    } \
} while(false)

void emit_decode_error(ivec2 coord)
{
    if (DECODE_8BIT)
        imageStore(OutputImageU8, coord, uvec4(0xff, 0, 0xff, 0xff));
    else
        imageStore(OutputImageFP16, coord, uvec4(0xffff));
}

void main()
{
    ivec4 coord = build_coord();
    debug_coord = uvec3(coord.xy, 0);
    if (any(greaterThanEqual(coord.xy, registers.resolution)))
        return;

    ivec2 pixel_coord = ivec2(gl_LocalInvocationID.xy);
    int linear_pixel = int(gl_WorkGroupSize.x) * pixel_coord.y + pixel_coord.x;
    uvec4 payload = texelFetch(PayloadInput, coord.zw, 0);

    BlockMode block_mode = decode_block_mode(payload);
    CHECK_DECODE_ERROR();

    int weight_cost_bits;
    ivec4 weights = decode_weights(payload, block_mode, linear_pixel, weight_cost_bits);

    int available_endpoint_bits = 128 - block_mode.config_bits - weight_cost_bits;
    int num_endpoint_pairs = (block_mode.cem >> 2) + 1;
    ivec4 endpoint_quant = ivec4(texelFetch(LUTRemainingBitsToEndpointQuantizer,
            128 * (num_endpoint_pairs - 1) + available_endpoint_bits));

    // No space left for color endpoints.
    if (all(equal(endpoint_quant.xyz, ivec3(0))))
        decode_error = true;
    CHECK_DECODE_ERROR();

    int endpoint_bit_offset = block_mode.config_bits;
    ivec4 ep0, ep1;
    bool HDR;
    decode_endpoint(ep0, ep1, HDR, payload, endpoint_bit_offset, endpoint_quant,
            block_mode.cem, available_endpoint_bits);
    CHECK_DECODE_ERROR();

    ivec4 final_color = interpolate_endpoint(ep0, ep1, weights, HDR);

    DEBUG3(ep0.x, ep0.y, ep0.z);
    DEBUG1(ep0.w);
    DEBUG3(ep1.x, ep1.y, ep1.z);
    DEBUG1(ep1.w);
    DEBUG1(weights.x);

    if (DECODE_8BIT)
    {
        imageStore(OutputImageU8, coord.xy, uvec4(final_color >> 8));
    }
    else
    {
        uvec4 encoded = decode_fp16(final_color);
        imageStore(OutputImageFP16, coord.xy, encoded);
    }
}