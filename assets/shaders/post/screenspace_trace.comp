#version 450
#extension GL_EXT_samplerless_texture_functions : require
layout(local_size_x = 8, local_size_y = 8) in;

#pragma optimize off
#include "../inc/project_direction.h"

layout(set = 0, binding = 0) uniform texture2D uDepth;
layout(set = 0, binding = 1) uniform texture2D uNormal;
layout(set = 0, binding = 2) uniform texture2D uPBR;
layout(set = 0, binding = 3) writeonly uniform image2D uOutputUV;

layout(set = 1, binding = 0) uniform UBO
{
    mat4 view_projection;
    mat4 inv_view_projection;
    vec2 inv_resolution;
    uvec2 resolution;
    vec3 camera_position;
};

vec2 trace_screenspace(vec3 start, vec3 d)
{
    vec3 inv_d = 1.0 / d;
    float d_z = 1.0 - start.z;
    float t = d_z * inv_d.z;
    vec3 ndc = start + t * d;
    return ndc.xy;
}

vec2 trace_inner()
{
    uvec2 coord = gl_GlobalInvocationID.xy;
    if (any(greaterThanEqual(coord, resolution)))
        return vec2(-10.0);

    vec2 uv = (vec2(coord) + 0.5) * inv_resolution;
    vec2 clip_uv = 2.0 * uv - 1.0;

    vec4 clip0 = inv_view_projection * vec4(clip_uv, 0.0, 1.0);
    vec3 d = normalize(clip0.xyz - camera_position * clip0.w);

    if (d.y >= 0 || camera_position.y <= 0.001)
        return vec2(-10.0);

    vec3 inv_d = 1.0 / d;
    float t = -camera_position.y * inv_d.y;

    if (t <= 0.0)
        return vec2(-10.0);

    vec3 init_pos = camera_position + t * d;

    // Reflect against N = (0, 1, 0). World normal.
    d.y = -d.y;

    vec4 c = view_projection * vec4(init_pos, 1.0);
    vec3 init_clip = c.xyz / c.w;
    vec3 screen_space_dir = project_direction_to_clip_space(init_clip, d, view_projection);

    init_clip.xy = 0.5 * init_clip.xy + 0.5;
    screen_space_dir.xy *= 0.5;
    return trace_screenspace(init_clip, screen_space_dir);
}

void main()
{
    vec2 uv = trace_inner();
    // Shift to [-0.5, 0.5] range for more FP16 precision.
    imageStore(uOutputUV, ivec2(gl_GlobalInvocationID.xy), vec4(uv - 0.5, 1.0, 0.0));
}