#version 450
#extension GL_EXT_samplerless_texture_functions : require
layout(local_size_x = 8, local_size_y = 8) in;

#pragma optimize off
#include "../inc/project_direction.h"

layout(set = 0, binding = 0) uniform texture2D uDepth;
layout(set = 0, binding = 1) uniform texture2D uNormal;
layout(set = 0, binding = 2) uniform texture2D uPBR;
layout(set = 0, binding = 3) writeonly uniform image2D uOutputUV;

layout(set = 1, binding = 0) uniform UBO
{
    mat4 view_projection;
    mat4 inv_view_projection;
    vec2 inv_resolution;
    uvec2 resolution;
    vec3 camera_position;
};

vec2 trace_screenspace(vec3 start, vec3 d)
{
    if (d.z <= 0.0)
        return vec2(-10.0);

    vec3 inv_d = 1.0 / d;
    float d_z = 1.0 - start.z;
    float t = d_z * inv_d.z;
    vec3 ndc = start + t * d;
    return ndc.xy;
}

vec2 trace_inner()
{
    uvec2 coord = gl_GlobalInvocationID.xy;
    if (any(greaterThanEqual(coord, resolution)))
        return vec2(-10.0);

    vec2 uv = (vec2(coord) + 0.5) * inv_resolution;
    vec2 clip_uv = 2.0 * uv - 1.0;

    float clip_depth = texelFetch(uDepth, ivec2(coord), 0).x;
    if (clip_depth == 1.0)
        return vec2(-10.0);

    vec3 N = normalize(texelFetch(uNormal, ivec2(coord), 0).xyz * 2.0 - 1.0);
    vec4 world_clip = inv_view_projection * vec4(clip_uv, clip_depth, 1.0);
    vec3 world_pos = world_clip.xyz / world_clip.w;
    vec3 d = normalize(world_pos - camera_position);

    d = reflect(d, N);
    vec3 screen_space_dir = project_direction_to_clip_space(vec3(clip_uv, clip_depth), d, view_projection);

    vec3 ndc = vec3(uv, clip_depth);
    screen_space_dir.xy *= 0.5;
    return trace_screenspace(ndc, screen_space_dir);
}

void main()
{
    vec2 uv = trace_inner();
    // Shift to [-0.5, 0.5] range for more FP16 precision.
    imageStore(uOutputUV, ivec2(gl_GlobalInvocationID.xy), vec4(uv - 0.5, 1.0, 0.0));
}