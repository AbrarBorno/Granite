#version 450
#extension GL_EXT_samplerless_texture_functions : require
layout(local_size_x = 64) in;

#define SUBGROUP_OPS
#include "../inc/subgroup_extensions.h"

layout(set = 2, binding = 8) buffer RayCounter
{
    uvec4 indirect;
    uvec4 indirect_fallback;
    uint count;
    uint fallback_count;
    uint copied_count;
    uint copied_fallback_count;
} ray_counter;

layout(set = 2, binding = 9) writeonly buffer RayList
{
    uint data[];
} ray_list;

layout(set = 3, binding = 0) uniform UBO
{
    mat4 view_projection;
    mat4 inv_view_projection;
    vec2 float_resolution;
    vec2 inv_resolution;
    uvec2 resolution;
    int max_lod;
    int frame;
    vec3 camera_position;
    uint resolution_1d;
};

layout(set = 2, binding = 0) uniform texture2D uDepth;
layout(set = 2, binding = 3) uniform mediump texture2D uPBR;

shared uint shared_tile_count;

bool is_reflective(uvec2 coord)
{
    float d = texelFetch(uDepth, ivec2(coord), 0).x;
    return d < 1.0;
}

bool is_glossy(float roughness)
{
    const float roughness_threshold = 0.2;
    return roughness < roughness_threshold;
}

bool is_mirror_reflection(mediump float roughness)
{
    return roughness < 0.0001;
}

bool is_base_ray(uvec2 coord)
{
    return all(equal(coord & 1u, uvec2(0)));
}

uint pack_ray(uvec2 coord, bool copy_horiz, bool copy_vert, bool copy_diag)
{
    return coord.x | (coord.y << 14u) |
        (uint(copy_horiz) << 28u) |
        (uint(copy_vert) << 29u) |
        (uint(copy_diag) << 30u);
}

void classify_tiles(uvec2 global_coord, uvec2 local_coord, float roughness)
{
    if (gl_LocalInvocationIndex == 0u)
        shared_tile_count = 0u;

    bool needs_ray = all(lessThan(global_coord, resolution));
    bool is_reflective_surface = is_reflective(global_coord);
    bool is_glossy_reflection = is_glossy(roughness);
    needs_ray = needs_ray && is_glossy_reflection && is_reflective_surface;

    // Also we dont need to run the denoiser on mirror reflections.
    bool needs_denoiser = needs_ray && !is_mirror_reflection(roughness);

    // Decide which ray to keep
    bool is_base_ray = is_base_ray(global_coord);
    needs_ray = needs_ray && (!needs_denoiser || is_base_ray); // Make sure to not deactivate mirror reflection rays.

    barrier();

    if (is_glossy_reflection && is_reflective_surface)
        atomicAdd(shared_tile_count, 1u);

    // Next we have to figure out for which pixels that ray is creating the values for.
    // Thus, if we have to copy its value horizontal, vertical or across.
    // Our pixel only requires a copy if we want to run a denoiser on it but don't want to shoot a ray for it.
    bool require_copy = !needs_ray && needs_denoiser;
    bool horiz_require_copy = subgroupQuadSwapHorizontal(require_copy);
    bool vert_require_copy = subgroupQuadSwapVertical(require_copy);
    bool diag_require_copy = subgroupQuadSwapDiagonal(require_copy);
    bool copy_horizontal = is_base_ray && horiz_require_copy;
    bool copy_vertical = is_base_ray && vert_require_copy;
    bool copy_diagonal = is_base_ray && diag_require_copy;

    // Thus, we need to compact the rays and append them all at once to the ray list.

    if (needs_ray)
    {
        uint ray_index = atomicAdd(ray_counter.count, 1u);
        ray_list.data[ray_index] = pack_ray(global_coord, copy_horizontal, copy_vertical, copy_diagonal);
    }

    bool needs_fallback_ray = is_reflective_surface && !is_glossy_reflection;
    if (needs_fallback_ray)
    {
        uint ray_index = base_ray_index + local_ray_index_in_wave + resolution_1d;
        ray_list.data[ray_index] = global_coord.x | (global_coord.y << 16u);
    }

    // TODO: Append denoiser tile.
}

void main()
{
    uvec2 coord = gl_WorkGroupID.xy * 8u;
    uint local = gl_SubgroupSize * gl_SubgroupID + gl_SubgroupInvocationID;
    uvec2 local_2d = uvec2(0);
    local_2d.x += bitfieldExtract(local, 0, 1) << 0;
    local_2d.x += bitfieldExtract(local, 2, 1) << 1;
    local_2d.x += bitfieldExtract(local, 4, 1) << 2;
    local_2d.y += bitfieldExtract(local, 1, 1) << 0;
    local_2d.y += bitfieldExtract(local, 3, 1) << 1;
    local_2d.y += bitfieldExtract(local, 5, 1) << 2;
    coord += local_2d;

    float roughness = texelFetch(uPBR, ivec2(coord), 0).g;
    classify_tiles(coord, local_2d, roughness);
}
