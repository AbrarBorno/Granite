#version 450
#extension GL_KHR_shader_subgroup_shuffle : require
#extension GL_KHR_shader_subgroup_basic : require
layout(local_size_x = 128) in;

layout(set = 0, binding = 0) readonly buffer Inputs
{
    uvec4 inputs[];
};

layout(set = 0, binding = 1) writeonly buffer Outputs
{
    uvec4 outputs[];
};

// Bit-matrix transpose in SIMD is a solved problem.
// From https://gist.github.com/raphlinus/59a7ab6a134828f5afdad8fcdaeb3388
// https://gist.github.com/bzm3r/a888c3f8a3255379941cd7003608e25a
// which appears to be a GPU adaption of the Hacker's Delight algorithm.
// Hierarchically transpose 16x16 blocks, then 8x8 blocks, and so on.
// Transposing columns is accomplished with ShuffleXor, and rows with bit shifts.
// Have to make this a macro since subgroupShuffleXor takes a compile time constant.
#define SHUFFLE_PASS(a, mimm, s) { \
    uvec4 b = subgroupShuffleXor(a, s); \
    uint m = mimm; \
    uvec4 c; \
    if ((gl_SubgroupInvocationID & s) == 0u) { \
        c = b << s; \
    } else { \
        m = ~m; \
        c = b >> s; \
    } \
    a = (a & m) | (c & ~m); \
}

uvec4 bit_transpose_4x32(uvec4 v)
{
    SHUFFLE_PASS(v, 0xffffu, 16);
    SHUFFLE_PASS(v, 0xff00ffu, 8);
    SHUFFLE_PASS(v, 0xf0f0f0fu, 4);
    SHUFFLE_PASS(v, 0x33333333u, 2);
    SHUFFLE_PASS(v, 0x55555555u, 1);
    return v;
}

shared uint shared_bank[4 * gl_WorkGroupSize.x];

void write_shared_transposed(uint index, uvec4 values)
{
    uint sub_index_y = index & 31u;
    uint base_index_y = index >> 5u;
    base_index_y += 4 * sub_index_y;

    shared_bank[0 * gl_WorkGroupSize.x + base_index_y] = values.x;
    shared_bank[1 * gl_WorkGroupSize.x + base_index_y] = values.y;
    shared_bank[2 * gl_WorkGroupSize.x + base_index_y] = values.z;
    shared_bank[3 * gl_WorkGroupSize.x + base_index_y] = values.w;
}

uvec4 read_shared_column(uint index)
{
    uint offset = index * 4;
    return uvec4(
        shared_bank[offset + 0],
        shared_bank[offset + 1],
        shared_bank[offset + 2],
        shared_bank[offset + 3]);
}

void main()
{
    uint index = gl_SubgroupInvocationID + gl_SubgroupID * gl_SubgroupSize;
    uvec4 d4 = inputs[index];

    // 128x128 bit matrix is computed here.
    // Scatter write so that we get a 4x4 transpose,
    // which then lets us transpose 16 32x32 bit matrices afterwards.
    write_shared_transposed(index, d4);
    barrier();
    d4 = read_shared_column(index);
    d4 = bit_transpose_4x32(d4);

    outputs[index] = d4;
}